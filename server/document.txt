// Test GRPC
grpcurl -plaintext localhost:50051 list                                                   â¬¡ 18.20.8 [Â±master â—â—]
grpcurl -plaintext -d '{"email":"test@example.com","password":"123456"}' localhost:50051 user.UserService/Login

// Wire 
echo 'export PATH=$PATH:$HOME/go/bin' >> ~/.zshrc
source ~/.zshrc

// Tree folder
Tá»•ng Quan Flow (gRPC â†’ DTO â†’ UseCase â†’ Command â†’ Handler â†’ Entity)

grpc â†’ dto â†’ mapper â†’ command â†’ handler â†’ response dto â†’ grpc

// gen descriptor.pb
protoc \
  -I./proto \
  -I./proto/google \
  --include_imports \
  --include_source_info \
  --descriptor_set_out=../server/envoy/all_services_descriptor.pb \
  $(find ./proto -name "*.proto")

// check descriptor
grpcurl -plaintext -import-path ./proto -proto ./proto/user/v1/user.proto list
grpcurl -plaintext -protoset envoy/all_services_descriptor.pb list

// generate key client
func main() {
	// ğŸ” Táº¡o Ä‘Æ°á»ng cong elliptic P-521
	curve := ecdh.P521()

	// ğŸ”‘ Táº¡o khÃ³a riÃªng client
	clientPriv, err := curve.GenerateKey(rand.Reader)
	if err != nil {
		log.Fatalf("Lá»—i táº¡o khÃ³a riÃªng: %v", err)
	}

	// ğŸ”“ Láº¥y khÃ³a cÃ´ng khai tá»« khÃ³a riÃªng
	clientPub := clientPriv.PublicKey()

	// ğŸ“¦ Encode khÃ³a cÃ´ng khai thÃ nh Base64 Ä‘á»ƒ dá»… truyá»n hoáº·c lÆ°u trá»¯
	pubKeyBytes := clientPub.Bytes()
	pubKeyBase64 := base64.StdEncoding.EncodeToString(pubKeyBytes)

	fmt.Println("ğŸ“¤ Client Public Key (Base64):")
	fmt.Println(pubKeyBase64)

	// ğŸ“¦ Encode khÃ³a riÃªng náº¿u cáº§n (khÃ´ng nÃªn truyá»n ra ngoÃ i náº¿u khÃ´ng cáº§n thiáº¿t)
	privKeyBytes := clientPriv.Bytes()
	privKeyBase64 := base64.StdEncoding.EncodeToString(privKeyBytes)

	fmt.Println("ğŸ” Client Private Key (Base64):")
	fmt.Println(privKeyBase64)
}

w5MCCq+SPdKaP8sq7ezKR7bza8eZNOvBr8ZElqFO3U8=

package main

import (
	"crypto/ecdh"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
)

type Payload struct {
	ClientPublicKey string `json:"clientPublicKey"`
}

func main() {
	// 1) Generate X25519 keypair
	curve := ecdh.X25519()
	priv, err := curve.GenerateKey(rand.Reader)
	if err != nil {
		log.Fatalf("generate key: %v", err)
	}

	// 2) Get raw public key bytes (32 bytes for X25519)
	pub := priv.PublicKey()
	rawPub := pub.Bytes()
	if len(rawPub) != 32 {
		log.Fatalf("unexpected public key length: %d", len(rawPub))
	}

	// 3) Base64-encode the raw public key
	b64Pub := base64.StdEncoding.EncodeToString(rawPub)

	// 4) Pack into JSON payload
	payload := Payload{ClientPublicKey: b64Pub}
	j, err := json.MarshalIndent(payload, "", "  ")
	if err != nil {
		log.Fatalf("marshal json: %v", err)
	}

	fmt.Println("JSON to send to server:")
	fmt.Println(string(j))

	// -------------------------
	// Demo: server-side quick check (decode & verify length)
	// -------------------------
	decoded, err := base64.StdEncoding.DecodeString(b64Pub)
	if err != nil {
		log.Fatalf("server decode base64: %v", err)
	}
	fmt.Printf("\nServer-side check: decoded length = %d bytes\n", len(decoded))
	// (server would then use its own X25519 private key and call srvPriv.ECDH(clientPub))
	_ = decoded // here just to show
}
