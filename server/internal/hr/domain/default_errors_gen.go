// Code generated by generate_errors.sh. DO NOT EDIT.
package domain

import "server/pkg/errors"

var (
	EMPLOYEE_NOT_FOUND = errors.BusinessError{
		Code: "HR-EMP-001",
		Status: 404,
		Message: "Employee not found",
		Severity: "S2",
		Retryable: false,
	}

	PAYROLL_PROCESS_FAIL = errors.BusinessError{
		Code: "HR-PAY-001",
		Status: 500,
		Message: "Payroll processing failed",
		Severity: "S1",
		Retryable: true,
	}

	LEAVE_REQUEST_INVALID = errors.BusinessError{
		Code: "HR-LEAVE-001",
		Status: 400,
		Message: "Invalid leave request",
		Severity: "S3",
		Retryable: false,
	}

	UNKNOWN_DOMAIN_KEY = errors.BusinessError{
		Code: "AUTH-VAL-999",
		Status: 400,
		Message: "Unknown domain error",
		Severity: "S1",
		Retryable: false,
	}

	INTERNAL_FALLBACK = errors.BusinessError{
		Code: "CORE-INF-000",
		Status: 500,
		Message: "Internal server error",
		Severity: "S1",
		Retryable: false,
	}

)

// ErrorByCode maps error codes to their BusinessError definitions
var ErrorByCode = map[string]errors.BusinessError{
	"HR-EMP-001": EMPLOYEE_NOT_FOUND,
	"HR-PAY-001": PAYROLL_PROCESS_FAIL,
	"HR-LEAVE-001": LEAVE_REQUEST_INVALID,
	"AUTH-VAL-999": UNKNOWN_DOMAIN_KEY,
	"CORE-INF-000": INTERNAL_FALLBACK,
}

// GetErrorByCode returns an error by code
func GetErrorByCode(code string) (errors.BusinessError, bool) {
    err, ok := ErrorByCode[code]
    return err, ok
}

// GetBusinessError converts an error to BusinessError if possible
func GetBusinessError(err error) (*errors.BusinessError, bool) {
    if be, ok := err.(*errors.BusinessError); ok {
        return be, true
    }
    return &UNKNOWN_DOMAIN_KEY, false
}

