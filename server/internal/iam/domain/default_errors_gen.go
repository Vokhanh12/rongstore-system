// Code generated by generate_errors.sh. DO NOT EDIT.
package domain

import "server/pkg/errors"

var (
	LOGIN_EMAIL_EMPTY = errors.BusinessError{
		Code: "AUTH-VAL-001",
		Status: 400,
		Message: "Email is required",
		Severity: "S3",
		Retryable: false,
	}

	LOGIN_EMAIL_INVALID = errors.BusinessError{
		Code: "AUTH-VAL-002",
		Status: 400,
		Message: "Invalid email format",
		Severity: "S3",
		Retryable: false,
	}

	LOGIN_PASSWORD_EMPTY = errors.BusinessError{
		Code: "AUTH-VAL-003",
		Status: 400,
		Message: "Password is required",
		Severity: "S3",
		Retryable: false,
	}

	LOGIN_PAYLOAD_INVALID = errors.BusinessError{
		Code: "AUTH-VAL-004",
		Status: 400,
		Message: "Invalid request payload",
		Severity: "S3",
		Retryable: false,
	}

	HANDSHAKE_INVALID_CLIENT_KEY = errors.BusinessError{
		Code: "AUTH-HAND-001",
		Status: 400,
		Message: "Invalid client public key",
		Severity: "S3",
		Retryable: false,
	}

	HANDSHAKE_KEY_AGREEMENT_FAIL = errors.BusinessError{
		Code: "AUTH-HAND-002",
		Status: 422,
		Message: "Key agreement failed",
		Severity: "S3",
		Retryable: false,
	}

	HANDSHAKE_RNG_FAIL = errors.BusinessError{
		Code: "AUTH-HAND-003",
		Status: 500,
		Message: "Random generation failed",
		Severity: "S1",
		Retryable: true,
	}

	HANDSHAKE_KEY_DERIVE_FAIL = errors.BusinessError{
		Code: "AUTH-HAND-004",
		Status: 500,
		Message: "Key derivation failed",
		Severity: "S1",
		Retryable: true,
	}

	HANDSHAKE_STORAGE_FAIL = errors.BusinessError{
		Code: "AUTH-HAND-005",
		Status: 500,
		Message: "Failed to store session",
		Severity: "S1",
		Retryable: true,
	}

	INVALID_CREDENTIALS = errors.BusinessError{
		Code: "AUTH-LOGIN-001",
		Status: 401,
		Message: "Invalid email or password",
		Severity: "S3",
		Retryable: false,
	}

	TOKEN_EXPIRED = errors.BusinessError{
		Code: "AUTH-TOKEN-001",
		Status: 401,
		Message: "Token expired",
		Severity: "S3",
		Retryable: false,
	}

	DB_TIMEOUT = errors.BusinessError{
		Code: "AUTH-INFRA-001",
		Status: 503,
		Message: "Database service temporarily unavailable",
		Severity: "S1",
		Retryable: true,
	}

	REDIS_UNAVAILABLE = errors.BusinessError{
		Code: "AUTH-INFRA-002",
		Status: 503,
		Message: "Redis cache temporarily unavailable",
		Severity: "S1",
		Retryable: true,
	}

	KEYCLOAK_UNAVAILABLE = errors.BusinessError{
		Code: "AUTH-INFRA-003",
		Status: 503,
		Message: "Keycloak service temporarily unavailable",
		Severity: "S1",
		Retryable: true,
	}

	UNKNOWN_DOMAIN_KEY = errors.BusinessError{
		Code: "AUTH-VAL-999",
		Status: 400,
		Message: "Unknown domain error",
		Severity: "S1",
		Retryable: false,
	}

	INTERNAL_FALLBACK = errors.BusinessError{
		Code: "CORE-INF-000",
		Status: 500,
		Message: "Internal server error",
		Severity: "S1",
		Retryable: false,
	}

)

// ErrorByCode maps error codes to their BusinessError definitions
var ErrorByCode = map[string]errors.BusinessError{
	"AUTH-VAL-001": LOGIN_EMAIL_EMPTY,
	"AUTH-VAL-002": LOGIN_EMAIL_INVALID,
	"AUTH-VAL-003": LOGIN_PASSWORD_EMPTY,
	"AUTH-VAL-004": LOGIN_PAYLOAD_INVALID,
	"AUTH-HAND-001": HANDSHAKE_INVALID_CLIENT_KEY,
	"AUTH-HAND-002": HANDSHAKE_KEY_AGREEMENT_FAIL,
	"AUTH-HAND-003": HANDSHAKE_RNG_FAIL,
	"AUTH-HAND-004": HANDSHAKE_KEY_DERIVE_FAIL,
	"AUTH-HAND-005": HANDSHAKE_STORAGE_FAIL,
	"AUTH-LOGIN-001": INVALID_CREDENTIALS,
	"AUTH-TOKEN-001": TOKEN_EXPIRED,
	"AUTH-INFRA-001": DB_TIMEOUT,
	"AUTH-INFRA-002": REDIS_UNAVAILABLE,
	"AUTH-INFRA-003": KEYCLOAK_UNAVAILABLE,
	"AUTH-VAL-999": UNKNOWN_DOMAIN_KEY,
	"CORE-INF-000": INTERNAL_FALLBACK,
}

// GetErrorByCode returns an error by code
func GetErrorByCode(code string) (errors.BusinessError, bool) {
    err, ok := ErrorByCode[code]
    return err, ok
}

// GetBusinessError converts an error to BusinessError if possible
func GetBusinessError(err error) (*errors.BusinessError, bool) {
    if be, ok := err.(*errors.BusinessError); ok {
        return be, true
    }
    return &UNKNOWN_DOMAIN_KEY, false
}

